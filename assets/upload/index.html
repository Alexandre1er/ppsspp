<!DOCTYPE html>
<!--upload-->
<!--TODO: Make localizable somehow.-->
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>File Uploader</title>
	<style>
		body {
			font-family: system-ui, sans-serif;
			background: #f5f7fa;
			color: #333;
			padding: 2em;
			max-width: 600px;
			margin: auto;
		}

		h1 {
			text-align: center;
			color: #444;
		}

		.section {
			margin-bottom: 1em;
		}

		input[type="file"] {
			display: block;
			margin: 0.5em 0;
		}

		button {
			display: inline-block;
			padding: 0.6em 1.2em;
			font-size: 1em;
			border: none;
			border-radius: 6px;
			background-color: #4a90e2;
			color: white;
			cursor: pointer;
			transition: background 0.2s;
			margin-right: 0.5em;
		}

		#uploadBtn:enabled {
			background-color: #3aa270;
		}

		button:disabled {
			background-color: #ccc;
			cursor: not-allowed;
		}

		button:hover:not(:disabled) {
			background-color: #357ab8;
		}

		.btn {
			display: inline-block;
			padding: 0.6em 1.2em;
			font-size: 1em;
			border: none;
			border-radius: 6px;
			background-color: #4a90e2;
			color: white;
			cursor: pointer;
			transition: background 0.2s;
			margin-right: 0.5em;
		}

		.btn:hover {
			background-color: #357ab8;
		}

		#fileList {
			margin-top: 0.5em;
			font-size: 0.95em;
			color: #333;
		}

		progress {
			width: 100%;
			height: 20px;
			margin-top: 0.5em;
			display: none;
		}

		#status {
			margin-top: 0.5em;
			font-weight: 500;
		}

		#error {
			color: #d33;
			margin-top: 0.5em;
		}

		pre.inline {
			display: inline;
		}

		.btn input[type="file"] {
			display: none; /* hide the native control */
		}

		#resetBtn {
			display: none; /* initially hidden */
		}
	</style>
</head>
<body>
	<h1>Upload files to {{ device_name }}</h1>

	<p>To folder: <pre class="inline">{{ upload_path }}</pre></p>

	<div class="section">
		<label class="btn">
			Choose individual files...
			<input type="file" id="fileInput" multiple hidden>
		</label>
		<label class="btn">
			Choose folder...
			<input type="file" id="folderInput" webkitdirectory multiple>
		</label>
		<button id="resetBtn">
			Reset
		</button>
	</div>

	<div id="fileList"></div>

	<div class="section">
		<button id="uploadBtn" disabled>Start upload!</button>
	</div>

	<progress id="progressBar" value="0" max="100"></progress>
	<div id="status"></div>
	<div id="error"></div>

	<script>
		(() => {
			const fileInput = document.getElementById("fileInput");
			const folderInput = document.getElementById("folderInput");
			const uploadBtn = document.getElementById("uploadBtn");
			const resetBtn = document.getElementById("resetBtn");
			const fileListDiv = document.getElementById("fileList");
			const progressBar = document.getElementById("progressBar");
			const statusDiv = document.getElementById("status");
			const errorDiv = document.getElementById("error");

			let files = [];
			function formatBytes(bytes, decimals = 2) {
				if (bytes === 0) return '0 B';
				const k = 1024;
				const units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
				const i = Math.floor(Math.log(bytes) / Math.log(k));
				const size = parseFloat((bytes / Math.pow(k, i)).toFixed(decimals));
				return `${size} ${units[i]}`;
			}
			function updateFileList() {
				files = [...fileInput.files, ...folderInput.files];
				fileListDiv.innerHTML = "";
				if (files.length > 0) {
					uploadBtn.disabled = false;
					resetBtn.style.display = "inline-block";
					const list = document.createElement("ul");
					files.forEach(f => {
						const li = document.createElement("li");
						const formattedBytes = formatBytes(f.size, 2);
						const name = f.webkitRelativePath || f.name;
						li.textContent = `${name} (${formattedBytes} bytes)`;
						list.appendChild(li);
					});
					fileListDiv.appendChild(list);
				} else {
					uploadBtn.disabled = true;
					resetBtn.style.display = "none";
				}
			}

			fileInput.addEventListener("change", updateFileList);
			folderInput.addEventListener("change", updateFileList);

			resetBtn.addEventListener("click", () => {
				// Clear the file inputs
				fileInput.value = "";
				folderInput.value = "";
				// Clear the files array and update the display
				files = [];
				updateFileList();
			});

			uploadBtn.addEventListener("click", async () => {
				if (files.length === 0) return;

				uploadBtn.disabled = true;
				errorDiv.textContent = "";
				statusDiv.textContent = "";
				progressBar.style.display = "block";
				progressBar.value = 0;

				for (let i = 0; i < files.length; i++) {
					const file = files[i];
					statusDiv.textContent = `Uploading ${file.webkitRelativePath || file.name} (${i + 1}/${files.length})`;

					try {
						await uploadFile(file);
					} catch (err) {
						errorDiv.textContent = err.message;
						progressBar.style.display = "none";
						uploadBtn.disabled = false;
						return;
					}
				}

				statusDiv.textContent = "All files uploaded successfully.";
				progressBar.style.display = "none";
				uploadBtn.disabled = false;
			});

			function uploadFile(file) {
				return new Promise((resolve, reject) => {
					const xhr = new XMLHttpRequest();
					xhr.open("POST", "/upload_file");

					// Add custom metadata headers if needed:
					xhr.setRequestHeader("X-Client-Version", "1.0");
					xhr.setRequestHeader("X-Upload-Timestamp", new Date().toISOString());

					xhr.upload.onprogress = e => {
						if (e.lengthComputable) {
							progressBar.value = (e.loaded / e.total) * 100;
						}
					};

					xhr.onload = () => {
						if (xhr.status >= 200 && xhr.status < 300) {
							resolve();
						} else {
							let msg;
							switch (xhr.status) {
								case 400: msg = "Malformed request (boundary or headers invalid)."; break;
								case 500: msg = "Target is probably out of disk space."; break;
								default: msg = `Upload failed with status ${xhr.status}.`; break;
							}
							reject(new Error(msg));
						}
					};

					xhr.onerror = () => reject(new Error("Connection error during upload."));

					// Try to preserve any directory structure, if supported.
					const formData = new FormData();
					formData.append("file", file, file.webkitRelativePath || file.name);
					xhr.send(formData);
				});
			}
		})();
	</script>
</body>
</html>
